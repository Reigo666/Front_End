1. ES6中var let const区别
```
    1. let const不能重复声明
    2. 块级作用域和暂时性死区：
        只要作用域内存在let、const，它们所声明的变量或常量就会自动“绑定”这个区域，不再受外部作用域的影响。
    3. let不存在变量提升
    4. var在全局作用域绑定可以通过window调用
```
2. cokkie localstorage sessionstorage三者的区别
```
    1. cookie数据大小不能大于4K；localStorage和sessionStorage则可以达到5M；
    2. cookie在设置的有效期内一直有效； localStorage存储持久数据，只要不手动清除则一直存在，无时间限制； sessionStorage数据在当前浏览器关闭后就会被自动清除
    3. cookie的数据会自动传递到服务器端，服务器端也可以写cookie到客户端;  localStorage和sessionStorage不会把数据自动传到服务器端，仅在本地存储。
    
```
3. 防抖和节流
```
    防抖：单位时间内，频繁触发事件，只执行最后一次
        - 典型场景：搜索框搜索输入，手机号邮箱号验证
        - 代码思路是利用定时器，每次触发先清掉以前的定时器。（从新开始）

    节流：单位时间内，频繁触发事件，直接执行一次
        - 典型场景：高频事件快速点击、滚动加载
        - 代码思路也是利用定时器，等定时器执行完毕，才开启定时器（不要打断）
    
    可以使用lodash库中的debounce（防抖）和throttle（节流）来做。
```
4. 强缓存和协商缓存
```
1.强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;

2.协商缓存：向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中（请求的资源未更新），则返回304状态码并带上新的response header通知浏览器从缓存中读取资源，如果资源更新则返回资源和状态码200；

两者的共同点是，都是从客户端缓存中读取资源；区别是强缓存不会发请求，协商缓存会发请求。
```
5. xss和csrf
```
    1.XSS 跨站脚本攻击(cross site script) csrf 跨站请求伪造(cross site request forgery)
    2.xss
        浏览器向服务器请求的时候被注入脚本攻击
        分成三种类型 反射型（非持久型）， 存储型（持久型），基于DOM
        防范手段：
            1.输入过滤
            2.输出过滤
            3.加httponly请求头 ，锁死cookie
    
    3.csrf
        黑客通过网站B 诱使用户去访问已经登陆的的网站A 进行一些违背用户意愿的请求，造成用户损失
        防范手段：
            1.服务器验证 http refer头信息 是否是同域名
            2.避免登录的session长时间存储在客户端中
            3.使用token或者验证码
```
6. OSI七层模型
```
    1.应用层    HTTP，FTP
    2.表示层    数据格式化，数据加密
    3.会话层    解除或建立与别的接点的联系
    4.传输层    TCP/UDP
    5.网络层    IP
    6.数据链路层
    7.物理层
```
7. HTTP和HTTPS的区别
```
    1. HTTPS是HTTP协议的安全版本，HTTP协议的数据传输是明文的，是不安全的，HTTPS使用了SSL/TLS协议进行了加密处理。
    2. http和https使用连接方式不同，默认端口也不一样，http是80，https是443。
```
8. 状态码
```
    301 302 304 400 401 404 500 503
    1XX- 信息型，服务器收到请求，需要请求者继续操作。
    2XX- 成功型，请求成功收到，理解并处理。
    3XX - 重定向，需要进一步的操作以完成请求。
    4XX - 客户端错误，请求包含语法错误或无法完成请求。
    5XX - 服务器错误，服务器在处理请求的过程中发生了错误。

    200 OK - 客户端请求成功
    301 - 资源（网页等）被永久转移到其它URL
    302 - 临时跳转
    304 – 页面长时间不更新
    400 Bad Request - 客户端请求有语法错误，不能被服务器所理解
    401 Unauthorized - 请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用
    404 - 请求资源不存在，可能是输入了错误的URL
    500 - 服务器内部发生了不可预期的错误
    503 Server Unavailable - 服务器当前不能处理客户端的请求，一段时间后可能恢复正常。
```
9.  跨域
```
    跨域是指一个域下的文档或脚本试图去请求另一个域下的资源。
    同源策略：一个源指的是主机名、协议和端口号的组合，必须相同

    1.jsonp
    2.跨域资源共享（CORS） Access-Control-Allow-Origin
    3.nginx代理: a网站向b网站请求1.js文件时，nginx根据配置文件接收这个请求，代替a网站向b网站来请求这个资源，nginx拿到这个资源后再返回给a网站，以此来解决了跨域问题。
    
```
10. UDP和TCP的区别
```
用户数据报协议 UDP（User Datagram Protocol）
    1.无连接的，尽最大可能交付，
    2.没有流量控制，拥塞控制
    3.面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部）
    4.支持一对一、一对多、多对一和多对多的交互通信。

传输控制协议 TCP（Transmission Control Protocol）
    1.面向连接的，提供可靠交付
    2.有流量控制，拥塞控制
    3.面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）
    4.每一条 TCP 连接只能是点对点的（一对一）。

TCP应用：
（1）FTP：文件传输协议；
（2）SSH：安全登录、文件传送(SCP)和端口重定向；
（3）Telnet：不安全的文本传送；
（4）SMTP：简单邮件传输协议Simple Mail Transfer Protocol (E-mail)；
（5）HTTP：超文本传送协议 (WWW)；

UDP应用：
（1）流媒体
采用TCP，一旦发生丢包，TCP会将后续包缓存起来，等前面的包重传并接收到后再继续发送，延迟会越来越大。基于UDP的协议如WebRTC是极佳的选择。
（2）实时游戏
对实时要求较为严格的情况下，采用自定义的可靠UDP协议，比如Enet、RakNet（用户有sony online game、minecraft）等，自定义重传策略，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成的影响。
采用UDP的经典游戏如FPS游戏Quake、CS，著名的游戏引擎Unity3D采用的也是RakNet。
（3）物联网
2014年google旗下的Nest建立Thread Group，推出了物联网通信协议Thread，完善物联网通信。
全球将近50%的人都在使用互联网，人们不断的追求更快、更好的服务，一切都在变化，在越来越多的领域，UDP将会抢占TCP的主导地位。
（4）QQ 文件传输、QQ语音、QQ视频
对于网络通讯质量要求不高的情况下，要求网络通讯速度能尽量快捷方便，就可以使用UDP技术。
```
11. TCP三次握手，四次挥手
![三次握手](https://img-blog.csdnimg.cn/6e968a961d7c48ff91a8a44768e54387.png#pic_center)
```
    问：为什么采用三次握手而不是两次握手?

    答：为了防止已失效的请求报文，突然又传到服务器引起错误。（如果一个SYN报文由于网络问题超时，超时后客户端重发与服务器端建立了连接，但网络恢复后原先SYN报文又发送到了服务器端，导致服务器端会认为有两条连接，而客户端认为只有一条连接。 如果有三次握手，则因为客户端收到服务器端第二次的SYN+ACK包后，由于超时不会再向客户端服务器端发送ACK，也不会使第二条连接成功。）
```
![四次挥手](https://img-blog.csdnimg.cn/c14df8b8c94a4c0e9066c77528df8c73.png#pic_center)
```
    终止等待1状态      关闭等待状态
    终止等待2状态      最后确认状态
    超时等待状态

    问：解释四次挥手。
    第一次挥手：客户端向服务器端发送FIN终止连接报文。客户端变为终止等待1状态。
    第二次挥手：服务器端向客户端发送ACK确认。服务器端变为关闭等待状态。
    第二次挥手与第三次挥手之间：服务器端可以持续向客户端发送未发送完的报文。
    第三次挥手：服务器端向客户端发送FIN报文。服务器端变为最后确认状态。
    第四次挥手：客户端向服务器端发送ACK。客户端变为超时等待状态。
               服务器端收到ACK后会立即进入关闭状态。

    问：为什么服务器端收到FIN后不立即关闭？
    答：因为服务器端可能有未发送完的报文需要继续发送。

    问：为什么客户端需要等待超时时间？
    答：因为客户端发完ACK后，服务器端可能因为网络原因接收不到。当服务器接收不到客户端ACK报文，由于超时，服务器会重新向客户端发送FIN报文，客户端此时处于超时等待状态会重新发送ACK报文，服务器接收到ACK报文后会立即关闭。

    问：四次挥手为什么是四次，三次不行吗？
    答：如果服务器直接发送FIN后直接关闭，而客户端没有收到FIN报文则会一直处于等待关闭状态。
```


12. http头部有哪些字段
```
    User-Agent:告诉服务器，客户端的操作系统和浏览器版本
    Accept：表示客户端期望服务器返回的媒体格式。 image/jpg,test/html,application
    Accept-Charset：表示客户端期望服务器端返回内容编码格式 gb2312
    Accept-Language：表示客户端期望服务器返回内容的语言 zh-cn
    Connect：告诉服务器，本次传输后是否保持连接，如keep-alive
    Content-Type：请求体内容类型，如Application,Multipart/form-data
    Content-length：表示传输请求响应内容的长度
    Cookie：客户端将Cookie信息传给服务器
    Cache-Control：缓存机制，如no-cache,public,privite等
    HOST：主机IP地址或域名
    Referer：当前文档的URL，表示从哪个站点链接过来的
    
```
13. 头部的content-type干嘛的
```
    GET 请求不存在请求体部分，请求头不需要设置 Content-Type 字段

    POST 请求：
        text/plain	                        文本文件默认值
        text/html	                        HTML格式，内容会解析为html网页格式
        application/json	                JSON数据格式
        application/x-www-form-urlencoded	数据发送过程中会对数据进行序列化处理，以键值对形式? key1=value1&key2=value2的方式发送到服务器（表单默认的提交数据的格式）
        application/octet-stream        二进制流数据（如常见的文件下载）
        multipart/form-data 	        需要在表单中进行文件上传时，就需要使用该格式
        image/gif	                    GIF 图片 (无损耗压缩方面被 PNG 所替代)
        image/jpeg	                    JPEG 图片
        image/png	                    PNG 图片

```
14. 1
15. 1
16. 1
17. 1
18. 1
19. 1
20. 1
21. 1


进程和线程的区别
进程之间的通信方式
http有什么问题，所以才会去用https去解决？
增加防抖功能
怎么做线程同步？
讲述浏览器渲染过程
你刚刚描述的过程，是dom树完全生成，才有这个渲染树吗？
a标签有哪些属性
target除了a标签有，还有哪些标签有target属性（我没问答出来）
const arr = ["8:15", "6:35", "11:22"]求平均
cookie的作用